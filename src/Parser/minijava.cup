/**
 * CUP specification of the language grammar for a simple demo language.
 * Change this into the language grammar of MiniJava for your implementation.
 *
 * CSE 401/M501/P501 19au, 20sp
 */

package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

/* Terminals (lexical tokens returned by the scanner): */

/* reserved words */
//terminal DISPLAY;
terminal RETURN, IF, ELSE, WHILE, STDOUT, STRING, INT, BOOL, TRUE, FALSE, THIS, NEW, PUBLIC, STATIC, VOID, MAIN, CLASS, EXTENDS, LENGTH;

/* operators */
terminal PLUS, BECOMES, AND, LTHAN, MINUS, TIMES, COMMA, DOT, NOT;

/* delimiters */
terminal LPAREN, RPAREN, SEMICOLON, LBRACKET, RBRACKET, LBRACE, RBRACE;

/* strings */
terminal String TEXT;

/* identifiers */
terminal String IDENTIFIER;

/* digits */
terminal Integer DIGIT; 




/* Nonterminals (constructed by parser): */

nonterminal List<Statement> Program;
nonterminal Statement Statement;
nonterminal Assign AssignStatement;
nonterminal Exp Expression;
nonterminal ExpList ExpressionList;
nonterminal Identifier Identifier;
nonterminal Type Type; 
nonterminal MainClass MainClass; 
nonterminal ClassDecl ClassDeclaration;
nonterminal VarDecl VarDeclaration;
nonterminal MethodDecl MethodDeclaration;
nonterminal Program Goal;
nonterminal ClassDeclList ClassDeclarationList;
nonterminal VarDeclList VarDeclarationList;
nonterminal MethodDeclList MethodDeclarationList;
nonterminal StatementList StatementList;
nonterminal Formal Formal;
nonterminal FormalList FormalList;


/* Precedence declarations: */

precedence nonassoc BECOMES; 

precedence nonassoc AND;
precedence nonassoc LTHAN; 
precedence left PLUS, MINUS; 
precedence left TIMES;
precedence right NEW;   
precedence right NOT; 
precedence left DOT; 

/* Productions: */

Goal ::= MainClass:m ClassDeclarationList:cdl 
    {: RESULT = new Program(m, cdl, mxleft); :}


MainClass ::= CLASS:c Identifier:id1 LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET Identifier:id2 RPAREN LBRACE Statement:statement RBRACE RBRACE
    {: RESULT = new MainClass(id1, id2, statement, cleft); :}

ClassDeclaration ::= CLASS Identifier:id LBRACE RBRACE
    {: RESULT = new ClassDecl(idxleft); :}
    | CLASS Identifier:id LBRACE VarDeclarationList:vdl MethodDeclarationList:mdl RBRACE
    {: RESULT = new ClassDeclSimple(id, vdl, mdl, idxleft); :}
    | CLASS Identifier:id1 EXTENDS Identifier:id2 LBRACE VarDeclarationList:vdl MethodDeclarationList:mdl RBRACE
    {: RESULT = new ClassDeclExtends(id1, id2, vdl, mdl, id1xleft); :}

VarDeclaration ::= Type:t Identifier:id SEMICOLON
    {: RESULT = new VarDecl(t, id, txleft); :}

MethodDeclaration ::= PUBLIC Type:t Identifier:id LPAREN RPAREN LBRACE VarDeclarationList:vdl StatementList:sl RETURN Expression:expr SEMICOLON RBRACE
    {: RESULT = new MethodDecl(t, id, new Formal(), vdl, sl, expr, idxleft); :}
    | MethodDeclaration ::= PUBLIC Type:t Identifier:id LPAREN FormalList:fl RPAREN LBRACE VarDeclarationList:vdl StatementList:sl RETURN Expression:expr SEMICOLON RBRACE
    {: RESULT = new MethodDecl(t, id, fl, vdl, sl, expr, idxleft); :}

Program ::= Statement:s
            {: List<Statement> p = new LinkedList<Statement>();
               p.add(s);
               RESULT = p; :}
        | Program:p Statement:s
            {: p.add(s); RESULT = p; :};

Type ::= INT:integer LBRACKET RBRACKET 
    {: RESULT = new IntArrayType(integerleft); :}
    | BOOL:boolean 
    {: RESULT = new BooleanType(booleanleft); :}
    | INT:integer 
    {: RESULT = new IntegerType(integerleft); :}
    | Identifier:id 
    {: RESULT = new IdentifierType(id.toString(), idleft); :}

Statement   ::= LBRACE StatementList:sl RBRACE
                {: RESULT = new StatementList(slxleft); :}
            | IF LPAREN Expression:expr RPAREN Statement:statement1 ELSE Statement:statement2
                {: RESULT = new If(expr, statement1, statement2, statement1xleft); :}
            | WHILE LPAREN Expression:expr RPAREN Statement:statement
                {: RESULT = new While(expr, statement, statement1xleft); :}
            | STDOUT LPAREN Expression:expr RPAREN SEMICOLON
                {: RESULT = new Print(expr, exprxleft); :}
            | Identifier:id BECOMES Expression:expr SEMICOLON
                {: RESULT = new Assign(id, expr, idxleft); :};
            | Identifier:id LBRACKET Expression:expr1 RBRACKET BECOMES Expression:expr2 SEMICOLON
                {: RESULT = new ArrayAssign(id, expr1, expr2, idxleft); :};
            /*
            AssignStatement:s
                {: RESULT = s; :}
            | DisplayStatement:s
                {: RESULT = s; :};
            */

/*
AssignStatement ::= Identifier:id BECOMES Expression:expr SEMICOLON
                    {: RESULT = new Assign(id, expr, idxleft); :};
*/

Identifier  ::= IDENTIFIER:id
                {: RESULT = new Identifier(id, idxleft); :};
/*
DisplayStatement ::= DISPLAY:d Expression:expr SEMICOLON
                     {: RESULT = new Display(expr, dxleft); :};
*/
ExpressionList ::=
    {: RESULT = new ExpList(0); :};
    | Expression:expr ExpressionList:el
        {: RESULT = el;
        RESULT.add(expr); :};

ClassDeclarationList ::= 
    {: RESULT = new ClassDeclList(0); :};
    | ClassDeclaration:cd ClassDeclarationList:cdl 
        {: RESULT = cdl;
        RESULT.add(cd); :};

MethodDeclarationList ::= 
    {: RESULT = new MethodDeclList(0); :};
    | MethodDeclaration:md MethodDeclarationList:mdl 
        {: RESULT = mdl;
        RESULT.add(md); :};

VarDeclarationList ::= 
    {: RESULT = new VarDeclList(0); :};
    | VarDeclaration:vd VarDeclarationList:vdl 
        {: RESULT = vdl;
        RESULT.add(vd); :};

StatementList ::= 
    {: RESULT = new StatementList(0); :};
    | statement:s StatementList:sl 
        {: RESULT = sl;
        RESULT.add(s); :};

FormalList ::= 
    {: RESULT = new FormalList(0); :};
    | Formal:f FormatList:fl 
        {: RESULT = fl;
        RESULT.add(f); :};

Formal ::= Type:t Identifier:id 
    {: RESULT = new Formal(t, id, tleft); :};

Expression    ::= Expression:arg1 AND Expression:arg2
            {: RESULT = new And(arg1, arg2, arg1xleft); :}
        | Expression:arg1 LTHAN Expression:arg2
            {: RESULT = new LessThan(arg1, arg2, arg1xleft); :}
        | Expression:arg1 PLUS Expression:arg2
            {: RESULT = new Plus(arg1, arg2, arg1xleft); :}
        | Expression:arg1 MINUS Expression:arg2 
            {: RESULT = new Minus(arg1, arg2, arg1xleft); :}
        | Expression:arg1 TIMES Expression:arg2
            {: RESULT = new Times(arg1, arg2, arg1xleft); :}
        | Expression:arg1 LBRACKET Expression:arg2 RBRACKET
            {: RESULT = new ArrayLookup(arg1, arg2, arg1xleft); :}
        | Expression:arg1 DOT LENGTH 
            {: RESULT = new ArrayLength(arg1, arg1xleft); :}
        | Expression:expr1 DOT Identifier:id LPAREN ExpressionList:el RPAREN
            {: RESULT = new Call(expr1, id, el, expr1left); :}
        | DIGIT:arg
            {: RESULT = new IntegerLiteral(arg, argleft); :}
        | TRUE:arg
            {: RESULT = new True(argleft); :}
        | FALSE:arg 
            {: RESULT = new False(argleft); :}
        | IDENTIFIER:name
            {: RESULT = new IdentifierExp(name, namexleft); :}
        | THIS:arg 
            {: RESULT = new This(argleft); :}
        | NEW INT LBRACKET Expression:expr RBRACKET 
            {: RESULT = new NewArray(expr, exprleft); :}
        | NEW IDENTIFIER:arg LPAREN RPAREN 
            {: RESULT = new NewObject(arg, argleft); :}
        | NOT Expression:expr 
            {: RESULT = new Not(expr, exprleft); :}
        | LPAREN Expression:expr RPAREN
            {: RESULT = expr; :};